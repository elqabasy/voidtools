#!/bin/bash
# whatenc.sh - Detect and decode various encodings
# Author: Generated by AI
# Compatible with Bash 4+
# Pipe-friendly version: informational messages go to stderr

# -------------------------
# Configurable Colors
# -------------------------
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# -------------------------
# Supported Encodings
# -------------------------
ENCODINGS=("base64" "base32" "hex" "rot13" "rot47" "url" "ascii85")

# -------------------------
# Helper Functions
# -------------------------

banner() {
  if [[ $QUIET -eq 0 ]]; then
    cat >&2 << "EOF"
    ██╗    ██╗██╗  ██╗ █████╗ ███████╗███╗   ██╗ ██████╗
    ██║    ██║██║  ██║██╔══██╗██╔════╝████╗  ██║██╔════╝
    ██║ █╗ ██║███████║███████║█████╗  ██╔██╗ ██║██║
    ██║███╗██║██╔══██║██╔══██║██╔══╝  ██║╚██╗██║██║
    ╚███╔███╔╝██║  ██║██║  ██║███████╗██║ ╚████║╚██████╗
    ╚══╝╚══╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝ ╚═════╝
            Site Cloner & Discovery Tool
EOF
  fi
}

print_help() {
  banner
  cat >&2 << EOF
Usage: whatenc [options] [file(s)]

Options:
  -d                 Decode detected encoding
  -o <file>          Output decoded content to file
  -v                 Verbose output
  -q, --quiet        Suppress banners and extra messages
  -h, --help         Show this help message
  --list-encodings   List all supported encodings

Input methods:
  - File path
  - Pipe: cat file | whatenc
  - Here-string: whatenc << "encoded_text"
  - Direct argument: whatenc "encoded_text"

Examples:
  whatenc encoded.txt
  cat encoded.txt | whatenc -d
  whatenc -d << "c29tZSBlbmNvZGluZw=="
EOF
}

list_encodings() {
  echo "Supported encodings:" >&2
  for e in "${ENCODINGS[@]}"; do
    echo "  - $e" >&2
  done
}

error_exit() {
  echo -e "${RED}[Error] $1${NC}" >&2
  exit "$2"
}

verbose_log() {
  if [[ $VERBOSE -eq 1 && $QUIET -eq 0 ]]; then
    echo -e "${YELLOW}[Verbose] $1${NC}" >&2
  fi
}


# -------------------------
# Encoding Detection
# -------------------------
detect_encoding() {
  local input="$1"
  # Base64
  if [[ "$input" =~ ^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$ ]]; then
    echo "base64"; return
  fi
  # Base32
  if [[ "$input" =~ ^([A-Z2-7]{8})*([A-Z2-7]{2}====|[A-Z2-7]{4}===|[A-Z2-7]{5}==|[A-Z2-7]{7}=)?$ ]]; then
    echo "base32"; return
  fi
  # Hex
  if [[ "$input" =~ ^[0-9a-fA-F]+$ ]]; then
    echo "hex"; return
  fi
  # ROT13 (letters only)
  if [[ "$input" =~ ^[A-Za-z]+$ ]]; then
    echo "rot13"; return
  fi
  # URL encoding
  if [[ "$input" =~ %([0-9A-Fa-f]{2}) ]]; then
    echo "url"; return
  fi
  # ROT47
  if [[ "$input" =~ [\x21-\x7E]+ ]]; then
    echo "rot47"; return
  fi
  echo "unknown"
}

# -------------------------
# Decoding Functions
# -------------------------
decode_encoding() {
  local enc="$1"
  local input="$2"
  case $enc in
    base64)
      echo "$input" | base64 --decode 2>/dev/null
      ;;
    base32)
      echo "$input" | base32 --decode 2>/dev/null
      ;;
    hex)
      echo "$input" | xxd -r -p 2>/dev/null
      ;;
    rot13)
      echo "$input" | tr 'A-Za-z' 'N-ZA-Mn-za-m'
      ;;
    rot47)
      echo "$input" | perl -pe 'tr[\!-~][P-~\!-O]'
      ;;
    url)
      echo -e "$(printf '%b' "${input//%/\\x}")"
      ;;
    ascii85)
      echo "$input" | perl -MConvert::ASCII85 -ne 'print ascii85_decode($_)'
      ;;
    *)
      error_exit "Decoding for $enc not implemented" 2
      ;;
  esac
}

# -------------------------
# Main Logic
# -------------------------

# Flags
DECODE=0
VERBOSE=0
QUIET=0
OUTPUT_FILE=""

# Parse options
ARGS=()
while [[ $# -gt 0 ]]; do
  case $1 in
    -d) DECODE=1; shift ;;
    -v) VERBOSE=1; shift ;;
    -q|--quiet) QUIET=1; shift ;;
    -h|--help) print_help; exit 0 ;;
    --list-encodings) list_encodings; exit 0 ;;
    -o) OUTPUT_FILE="$2"; shift 2 ;;
    --) shift; break ;;
    -*) error_exit "Unknown option $1" 1 ;;
    *) ARGS+=("$1"); shift ;;
  esac
done



# Determine input
INPUT=""
if [ -p /dev/stdin ]; then
  INPUT=$(cat)
elif [ ${#ARGS[@]} -gt 0 ]; then
  if [ -f "${ARGS[0]}" ]; then
    INPUT=$(cat "${ARGS[0]}")
  else
    INPUT="${ARGS[0]}"
  fi
else
  error_exit "No input provided" 1
fi

verbose_log "Input received: $INPUT"

# Detect encoding
ENCODE_TYPE=$(detect_encoding "$INPUT")
if [[ $ENCODE_TYPE == "unknown" ]]; then
  error_exit "Could not detect encoding type." 1
else
  echo "Detected encoding: $ENCODE_TYPE" >&2
fi

# Decode if requested
if [[ $DECODE -eq 1 ]]; then
  verbose_log "Decoding input..."
  DECODED=$(decode_encoding "$ENCODE_TYPE" "$INPUT")
  if [[ $? -ne 0 || -z "$DECODED" ]]; then
    error_exit "Decoding failed" 2
  fi
  if [[ -n "$OUTPUT_FILE" ]]; then
    echo "$DECODED" > "$OUTPUT_FILE"
    echo "Decoded output written to $OUTPUT_FILE" >&2
  else
    echo "$DECODED"
  fi
fi
