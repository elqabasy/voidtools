#!/bin/bash

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SIG_DB="${SCRIPT_DIR}/signatures.db"
LOG_DIR="${SCRIPT_DIR}/logs"
LOG_FILE="${LOG_DIR}/sigil.log"
VERSION="1.2.0"
VERBOSE=0
FORCE=0
OUT_FILE=""

mkdir -p "$LOG_DIR"
touch "$LOG_FILE"

source "$SIG_DB"

log() {
    [[ $VERBOSE -eq 1 ]] && echo "[+] $1"
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

color_echo() {
    case "$1" in
        green) echo -e "\e[32m$2\e[0m" ;;
        red) echo -e "\e[31m$2\e[0m" ;;
        yellow) echo -e "\e[33m$2\e[0m" ;;
        *) echo "$2" ;;
    esac
}

banner() {
    echo "╔══════════════════════════╗"
    echo "║        SIGIL v$VERSION        ║"
    echo "╚══════════════════════════╝"
}

help_menu() {
    banner
    cat <<EOF
Usage: sigil.sh [options] <args>

Options:
  --get <type>                    Output raw signature for given type
  --prepend <type> <file>         Prepend signature to file
  --remove [<type>] <file>        Remove matching or detected signature
  --replace [<old>] <new> <file>  Replace matching or detected signature
  --check <file>                  Check file's signature
  --list                          List known types
  --banner                        Show tool banner
  --version                       Show version
  -v                              Enable verbose logging
  --force                         Overwrite output file if it exists
  --output <file>, -o <file>      Set output file name
  --help                          Show this help menu
EOF
    exit 0
}

error_exit() {
    color_echo red "Error: $1"
    log "ERROR: $1"
    exit 1
}

normalize_type() {
    echo "$1" | tr '[:upper:]' '[:lower:]'
}

detect_signature_type() {
    file="$1"
    head_bytes=$(head -c 12 "$file" | xxd -p)
    for key in "${!SIGNATURES[@]}"; do
        hex_sig=$(echo -ne "${SIGNATURES[$key]}" | xxd -p)
        if [[ "$head_bytes" == "$hex_sig"* ]]; then
            echo "$key"
            return
        fi
    done
    echo ""
}

prepend_sig() {
    type=$(normalize_type "$1")
    file="$2"

    [[ ! -f "$file" ]] && error_exit "File not found: $file"
    [[ -z "${SIGNATURES[$type]:-}" ]] && error_exit "Unknown type: $type"

    [[ -z "$OUT_FILE" ]] && OUT_FILE="sigil_prepended_$(basename "$file")"
    [[ -f "$OUT_FILE" && $FORCE -ne 1 ]] && error_exit "Output file exists: $OUT_FILE"

    {
        echo -ne "${SIGNATURES[$type]}"
        cat "$file"
    } > "$OUT_FILE"

    color_echo green "Prepended $type to $file -> $OUT_FILE"
    log "Prepended $type to $file"
}

remove_sig() {
    type=""
    file=""
    if [[ $# -eq 1 ]]; then
        file="$1"
        type=$(detect_signature_type "$file")
        [[ -z "$type" ]] && error_exit "No known signature detected in $file"
    elif [[ $# -eq 2 ]]; then
        type=$(normalize_type "$1")
        file="$2"
        [[ -z "${SIGNATURES[$type]:-}" ]] && error_exit "Unknown type: $type"
    else
        error_exit "Invalid usage for --remove"
    fi

    [[ ! -f "$file" ]] && error_exit "File not found: $file"

    sig_len=$(echo -ne "${SIGNATURES[$type]}" | wc -c)
    head_sig=$(head -c "$sig_len" "$file")

    [[ "$head_sig" != $(echo -ne "${SIGNATURES[$type]}") ]] && error_exit "Signature does not match for type '$type'"

    [[ -z "$OUT_FILE" ]] && OUT_FILE="sigil_removed_$(basename "$file")"
    [[ -f "$OUT_FILE" && $FORCE -ne 1 ]] && error_exit "Output file exists: $OUT_FILE"

    tail -c +$((sig_len + 1)) "$file" > "$OUT_FILE"

    color_echo green "Removed $type signature from $file -> $OUT_FILE"
    log "Removed $type signature from $file"
}

replace_sig() {
    old_type=""
    new_type=""
    file=""

    if [[ $# -eq 2 ]]; then
        new_type=$(normalize_type "$1")
        file="$2"
        old_type=$(detect_signature_type "$file")
        [[ -z "$old_type" ]] && error_exit "Could not detect any known signature"
    elif [[ $# -eq 3 ]]; then
        old_type=$(normalize_type "$1")
        new_type=$(normalize_type "$2")
        file="$3"
        [[ -z "${SIGNATURES[$old_type]:-}" ]] && error_exit "Unknown old type: $old_type"
    else
        error_exit "Invalid usage for --replace"
    fi

    [[ -z "${SIGNATURES[$new_type]:-}" ]] && error_exit "Unknown new type: $new_type"
    [[ ! -f "$file" ]] && error_exit "File not found: $file"

    old_sig_len=$(echo -ne "${SIGNATURES[$old_type]}" | wc -c)
    file_head=$(head -c "$old_sig_len" "$file")

    [[ "$file_head" != $(echo -ne "${SIGNATURES[$old_type]}") ]] && error_exit "File does not start with expected '$old_type' signature"

    [[ -z "$OUT_FILE" ]] && OUT_FILE="sigil_replaced_$(basename "$file")"
    [[ -f "$OUT_FILE" && $FORCE -ne 1 ]] && error_exit "Output file exists: $OUT_FILE"

    {
        echo -ne "${SIGNATURES[$new_type]}"
        tail -c +$((old_sig_len + 1)) "$file"
    } > "$OUT_FILE"

    color_echo green "Replaced $old_type with $new_type in $file -> $OUT_FILE"
    log "Replaced $old_type with $new_type in $file"
}

get_sig() {
    type=$(normalize_type "$1")
    [[ -z "${SIGNATURES[$type]:-}" ]] && error_exit "Unknown type: $type"
    echo -ne "${SIGNATURES[$type]}"
    log "Output signature for $type"
}

check_sig() {
    file="$1"
    [[ ! -f "$file" ]] && error_exit "File not found: $file"

    detected=$(detect_signature_type "$file")

    if [[ -n "$detected" ]]; then
        color_echo green "$file matches signature: $detected"
        log "$file detected as $detected"
    else
        color_echo yellow "$file: No known signature detected"
        log "$file has no known signature"
    fi
}

list_types() {
    echo "Available file types:"
    for key in "${!SIGNATURES[@]}"; do
        hex_val=$(echo -ne "${SIGNATURES[$key]}" | xxd -p)
        printf "  %-10s : %s\n" "$key" "$hex_val"
    done
}

ARGS=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        --get) shift; CMD="get"; ARGS+=("$1");;
        --prepend) shift; CMD="prepend"; ARGS+=("$1" "$2"); shift;;
        --remove) shift; CMD="remove"; ARGS+=("$1"); [[ "$1" != -* && $# -gt 1 ]] && ARGS+=("$2") && shift;;
        --replace) shift; CMD="replace"; ARGS+=("$1"); [[ "$1" != -* && $# -gt 1 ]] && ARGS+=("$2"); [[ "$2" != -* && $# -gt 2 ]] && ARGS+=("$3") && shift 2;;
        --check) shift; CMD="check"; ARGS+=("$1");;
        --list) CMD="list";;
        --banner) banner; exit 0;;
        --help) help_menu;;
        --version) echo "$VERSION"; exit 0;;
        --force) FORCE=1;;
        --output|-o) shift; OUT_FILE="$1";;
        -v) VERBOSE=1;;
        *) error_exit "Unknown option: $1";;
    esac
    shift
done

case "${CMD:-}" in
    get) get_sig "${ARGS[0]}";;
    prepend) prepend_sig "${ARGS[0]}" "${ARGS[1]}";;
    remove) remove_sig "${ARGS[@]}";;
    replace) replace_sig "${ARGS[@]}";;
    check) check_sig "${ARGS[0]}";;
    list) list_types;;
    *) help_menu;;
esac
